package zrpc

import (
	"fmt"
	"strings"

	pb "github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/rooobot/protoc-gen-zrpc/generator"
)

// Paths for packages used by code generated in this file,
// relative to the import_prefix of the generator.Generator.
const (
	zrpcServerPkgPath = "github.com/rooobot/zrpc"
	zrpcClientPkgPath = "github.com/rooobot/zrpc/client"
	zrpcInterceptorPkgPath = "github.com/rooobot/zrpc/interceptor"
)

func init() {
	generator.RegisterPlugin(new(zrpc))
}

type zrpc struct {
	gen *generator.Generator
}

// Name returns the name of this plugin
func (p *zrpc) Name() string {
	return "zrpc"
}

// Init initializes the plugin.
func (p *zrpc) Init(gen *generator.Generator) {
	p.gen = gen
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (p *zrpc) objectNamed(name string) generator.Object {
	p.gen.RecordTypeUse(name)
	return p.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (p *zrpc) typeName(str string) string {
	return p.gen.TypeName(p.objectNamed(str))
}

// GenerateImports generates the import declaration for this file.
func (p *zrpc) GenerateImports(file *generator.FileDescriptor) {
}

// P forwards to g.gen.P.
func (p *zrpc) P(args ...interface{}) {
	p.gen.P(args)
}

// Generate generates code for the services in the given file.
func (p *zrpc) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	_ = p.gen.AddImport(zrpcServerPkgPath)
	_ = p.gen.AddImport(zrpcClientPkgPath)
	_ = p.gen.AddImport(zrpcInterceptorPkgPath)
	_ = p.gen.AddImport("context")
	
	// generate all services
	for i, service := range file.FileDescriptorProto.Service {
		p.generateService(file, service, i)
	}
}

// generateService generates all the code for the named service
func (p *zrpc) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	originServiceName := service.GetName()
	serviceName := upperFirstLetter(originServiceName)
	p.P("// This following code was generated by protoc-gen-zrpc, DO NOT EDIT!!!")
	p.P()
	p.P("// =================== server skeleton ==================")
	p.P(fmt.Sprintf(`type %sService interface {
							`, serviceName))
	for _, method := range service.Method {
		p.generateServerInterfaceCode(method)
	}
	p.P("}")
	
	p.generateServiceDesc(service, file.GetPackage())
	for _, method := range service.Method {
		p.generateServerCode(service, method, file.GetPackage())
	}
	p.generateRegisterCode(service)

	p.P("// =================== client stub ==================")
	p.P(fmt.Sprintf(`// %sClientProxy is a client proxy for service %s.
			type %sClientProxy interface {
	`, serviceName, serviceName, serviceName))
	for _, method := range service.Method {
		p.generateClientInterfaceCode(method)
	}
	p.P("}")
	p.P(fmt.Sprintf(`
			type %sClientProxyImpl struct {
					client client.Client
					opts   []client.Option
			}
	`, serviceName))
	p.P(fmt.Sprintf(`
			func New%sClientProxy(opts ...clientOption) %sClientProxy {
					return &%sClientProxyImpl{client: client.DefaultClient, opts: opts}
			}
	`, serviceName, serviceName, serviceName))
	
	for _, method := range service.Method {
		p.generateClientCode(service, method, file.GetPackage())
	}
}

func (p *zrpc) generateRegisterCode(service *pb.ServiceDescriptorProto) {
	serviceName := upperFirstLetter(service.GetName())
	p.P(fmt.Sprintf(`
			func RegisterService(s *zrpc.Server, svr interface{}) {
				s.Register(_%s_serviceDesc, svr)
			}
	`, serviceName))
}

func (p *zrpc) generateServiceDesc(service *pb.ServiceDescriptorProto, pkgPath string) {
	serviceName := upperFirstLetter(service.GetName())
	p.P(fmt.Sprintf(`var _%s_serviceDesc = &zrpc.ServiceDesc {
			ServiceName: "%s.%s",
			HandlerType: (*%sService)(nil),
			Methods: []*zrpc.MethodDesc {
	`, serviceName, pkgPath, serviceName, serviceName))

	for _, method := range service.Method {
		methodName := upperFirstLetter(method.GetName())
		p.P(fmt.Sprintf(`{
				MethodName: "%s",
				Handler: %sService_%s_Handler,
		},`, methodName, serviceName, methodName))
	}

	p.P("},")
	p.P("}")
}

func (p *zrpc) generateServerInterfaceCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLetter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf("%s(ctx context.Context, req *%s) (*%s, error)",
		methodName, inType, outType))
}

func (p *zrpc) generateServerCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto, pkgName string) {
	methodName := upperFirstLetter(method.GetName())
	serviceName := upperFirstLetter(service.GetName())
	inType := p.typeName(method.GetInputType())
	p.P(fmt.Sprintf(`
			func %sSErvice_%s_Handler(ctx context.Context, svr interface{}, dec func(interface{}) error, ceps []interceptor.ServerInterceptor) (interface{}, error) {
				req := new(%s)
				if err := dec(req); err != nil {
					return nil, err
				}

				if len(ceps) == 0 {
					return svr.(%sService).%s(ctx, req)
				}

				handler := func(ctx context.Context, reqbody interface{}) (interface{}, error) {
					return svr.(%sService).%s(ctx, reqbody.(*%s))
				}

				return interceptor.ServerIntercept(ctx, req, ceps, handler)
			}
	`, serviceName, methodName, inType, serviceName, methodName, serviceName, methodName, inType))
}

func (p *zrpc) generateClientCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto, pkgName string) {
	methodName := upperFirstLetter(method.GetName())
	serviceName := upperFirstLetter(service.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf(`// %s is server rpc method as defined
			func (c *%sClientProxyImpl) %s(ctx context.Context, req *%s, opts ...client.Option) (*%s, error) {
					callopts := make([]client.Option, 0, len(c.opts)+len(opts))
					callopts = append(callopts, c.opts...)
					callopts = append(callopts, opts...)

					rsp := &%s{}
					err := c.client.Invoke(ctx, req, rsp, "/%s.%s/%s", callopts...)
					if err != nil {
						return nil, err
					}

					return rsp, nil
			}
	`, methodName, serviceName, methodName, inType, outType, outType, pkgName, serviceName, methodName))
}

func (p *zrpc) generateClientInterfaceCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLetter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf("%s(ctx context.Context, req *%s, opts ...clientOption) (*%s, error)",
		methodName, inType, outType))
}

// upperFirstLetter make the first character of given string to upper class
func upperFirstLetter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}